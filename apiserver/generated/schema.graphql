type Card implements Node {
  answers: [String!]!
  deckId: ID!
  editedAt: DateTime!
  fullAnswer: JSONObject
  id: ID!
  mainTemplate: Boolean!
  prompt: JSONObject
  template: Boolean!
}

"""
A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the `date-time` format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
"""
scalar DateTime

type Deck implements Node {
  answerLang: String!

  """
  all cards directly belonging to some descendant (reflexive, transitive closure of subdeck) deck of this deck
  """
  cardsAllUnder(after: ID, before: ID, first: Int, last: Int): DeckCardsAllUnderConnection!

  """all cards directly belonging to this deck"""
  cardsDirect(after: ID, before: ID, first: Int, last: Int): DeckCardsDirectConnection!

  """number of all cards directly belonging to this deck"""
  cardsDirectCount: Int!
  createdAt: DateTime!

  """
  all descendant decks (reflexive, transitive closure of subdeck) of this deck
  """
  descendantDecks: [Deck!]!
  description: JSONObject
  editedAt: DateTime!
  id: ID!
  name: String!
  ownRecordNotes: JSONObject
  owner: User!
  ownerId: ID!
  promptLang: String!
  sortData: [String!]!

  """all subdecks directly belonging to this deck"""
  subdecks(after: ID, before: ID, first: Int, last: Int): DeckSubdecksConnection!
  subdecksCount: Int!
}

type DeckCardsAllUnderConnection {
  edges: [DeckCardsAllUnderConnectionEdge]!
  pageInfo: PageInfo!
}

type DeckCardsAllUnderConnectionEdge {
  cursor: ID!
  node: Card!
}

type DeckCardsDirectConnection {
  edges: [DeckCardsDirectConnectionEdge]!
  pageInfo: PageInfo!
}

type DeckCardsDirectConnectionEdge {
  cursor: ID!
  node: Card!
}

type DeckSubdecksConnection {
  edges: [DeckSubdecksConnectionEdge]!
  pageInfo: PageInfo!
}

type DeckSubdecksConnectionEdge {
  cursor: ID!
  node: Deck!
}

"""ownership type of of decks returned"""
enum DecksQueryScope {
  OWNED
  VISIBLE
}

"""
A field whose value conforms to the standard internet email address format as specified in HTML Spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address.
"""
scalar EmailAddress

type Friendship implements Node {
  befriended: User!
  befriendedId: ID!
  befriender: User!
  befrienderId: ID!
  createdAt: DateTime!
  id: ID!
  updatedAt: DateTime!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

"""
A field whose value is a JSON Web Token (JWT): https://jwt.io/introduction.
"""
scalar JWT

type Message implements Node {
  content: JSONObject
  createdAt: DateTime!
  id: ID!
  room: Room!
  roomId: ID!
  sender: User!
  senderId: ID
  type: MessageContentType!
}

enum MessageContentType {
  CONFIG
  CONTEST_SCORE
  ROUND_SCORE
  ROUND_START
  ROUND_WIN
  TEXT
}

type Mutation {
  finalizeOauthSignin(code: String!, nonce: String!, provider: String!, redirect_uri: String!): SessionInfo
  initializeOauthSignin: String!
}

interface Node {
  id: ID!
}

type Occupant implements Node {
  createdAt: DateTime!
  id: ID!
  occupant: User!
  occupantId: ID!
  room: Room!
  roomId: ID!
  updatedAt: DateTime!
}

type PageInfo {
  endCursor: ID
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: ID
}

type Query {
  deck(id: ID!): Deck
  decks(after: ID, before: ID, first: Int, last: Int, scope: DecksQueryScope, stoplist: [ID!]): QueryDecksConnection!
  health: String!
  me: User
  node(id: ID!): Node
  nodes(ids: [ID!]!): [Node]!
}

type QueryDecksConnection {
  edges: [QueryDecksConnectionEdge]!
  pageInfo: PageInfo!
}

type QueryDecksConnectionEdge {
  cursor: ID!
  node: Deck!
}

type Room implements Node {
  createdAt: DateTime!
  deck: Deck!
  deckId: ID
  id: ID!
  messages(after: ID, before: ID, first: Int, last: Int): RoomMessagesConnection!
  slug: String
}

type RoomMessagesConnection {
  edges: [RoomMessagesConnectionEdge]!
  pageInfo: PageInfo!
}

type RoomMessagesConnectionEdge {
  cursor: ID!
  node: Message!
}

enum RoomState {
  SERVED
  SERVING
  WAITING
}

"""A token and its contained information"""
type SessionInfo {
  currentUser: JSONObject!
  token: JWT!
}

type Subdeck implements Node {
  createdAt: DateTime!
  id: ID!
  parentDeck: Deck!
  parentDeckId: ID!
  subdeck: Deck!
  subdeckId: ID!
  updatedAt: DateTime!
}

type Subscription {
  repeatHealth: String!
}

"""
A field whose value is a generic Universally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.
"""
scalar UUID

type User implements Node {
  """users this user has befriended"""
  befriendeds(after: ID, before: ID, first: Int, last: Int): UserBefriendedsConnection!
  befriendedsCount: Int!

  """users that have befriended this user and you"""
  befrienders(after: ID, before: ID, first: Int, last: Int): UserBefriendersConnection!
  befriendersCount: Int!
  bio: JSONObject
  decks(after: ID, before: ID, first: Int, last: Int): UserDecksConnection!
  facebookId: String
  googleId: String
  id: ID!

  """
  whether the user's profile information is accessible by non-friends and searchable
  """
  isPublic: Boolean!

  """
  users befriending you that this user has befriended; upon own user gives your mutual friends
  """
  mutualBefriendeds(after: ID, before: ID, first: Int, last: Int): UserMutualBefriendedsConnection!
  name: String!
  roles: [String!]!
}

type UserBefriendedsConnection {
  edges: [UserBefriendedsConnectionEdge]!
  pageInfo: PageInfo!
}

type UserBefriendedsConnectionEdge {
  cursor: ID!
  node: User!
}

type UserBefriendersConnection {
  edges: [UserBefriendersConnectionEdge]!
  pageInfo: PageInfo!
}

type UserBefriendersConnectionEdge {
  cursor: ID!
  node: User!
}

type UserDecksConnection {
  edges: [UserDecksConnectionEdge]!
  pageInfo: PageInfo!
}

type UserDecksConnectionEdge {
  cursor: ID!
  node: Deck!
}

type UserMutualBefriendedsConnection {
  edges: [UserMutualBefriendedsConnectionEdge]!
  pageInfo: PageInfo!
}

type UserMutualBefriendedsConnectionEdge {
  cursor: ID!
  node: User!
}