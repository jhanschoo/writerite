'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

const http = require('http');
const https = require('https');
const pino = _interopDefault(require('pino'));
const crossUndiciFetch = require('cross-undici-fetch');
const stream = require('stream');
const common = require('@graphql-yoga/common');
const LightMyRequest = _interopDefault(require('light-my-request'));
const graphql = require('graphql');
const core = require('@envelop/core');
const subscription = require('@graphql-yoga/subscription');

function getRequestAddressInfo(nodeRequest, defaultAddressInfo) {
    var _a, _b, _c, _d;
    const hostnameWithPort = (_b = (_a = nodeRequest.hostname) !== null && _a !== void 0 ? _a : nodeRequest.headers.host) !== null && _b !== void 0 ? _b : defaultAddressInfo.hostname;
    const [hostname = nodeRequest.hostname, port = defaultAddressInfo.port] = hostnameWithPort.split(':');
    return {
        protocol: (_c = nodeRequest.protocol) !== null && _c !== void 0 ? _c : defaultAddressInfo.protocol,
        hostname,
        endpoint: (_d = nodeRequest.url) !== null && _d !== void 0 ? _d : defaultAddressInfo.endpoint,
        port,
    };
}
function buildFullUrl(addressInfo) {
    return `${addressInfo.protocol}://${addressInfo.hostname}:${addressInfo.port}${addressInfo.endpoint}`;
}
async function getNodeRequest(nodeRequest, defaultAddressInfo) {
    const addressInfo = getRequestAddressInfo(nodeRequest, defaultAddressInfo);
    const fullUrl = buildFullUrl(addressInfo);
    const baseRequestInit = {
        method: nodeRequest.method,
        headers: nodeRequest.headers,
    };
    if (nodeRequest.method !== 'POST') {
        return new crossUndiciFetch.Request(fullUrl, baseRequestInit);
    }
    const maybeParsedBody = nodeRequest.body;
    if (maybeParsedBody) {
        return new crossUndiciFetch.Request(fullUrl, {
            ...baseRequestInit,
            body: typeof maybeParsedBody === 'string'
                ? maybeParsedBody
                : JSON.stringify(maybeParsedBody),
        });
    }
    const rawRequest = nodeRequest.raw || nodeRequest.req || nodeRequest;
    return new crossUndiciFetch.Request(fullUrl, {
        headers: nodeRequest.headers,
        method: nodeRequest.method,
        body: rawRequest,
    });
}
async function sendNodeResponse(responseResult, serverResponse) {
    responseResult.headers.forEach((value, name) => {
        serverResponse.setHeader(name, value);
    });
    serverResponse.statusCode = responseResult.status;
    serverResponse.statusMessage = responseResult.statusText;
    // Some fetch implementations like `node-fetch`, return `Response.body` as Promise
    const responseBody = await responseResult.body;
    if (responseBody.getReader) {
        const reader = responseBody.getReader();
        serverResponse.on('close', () => {
            reader.cancel();
        });
        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                break;
            }
            if (value) {
                serverResponse.write(value);
            }
        }
        if (!serverResponse.destroyed) {
            serverResponse.end();
        }
    }
    else {
        const nodeReadable = stream.Readable.from(responseBody);
        nodeReadable.pipe(serverResponse);
    }
}

function getPinoLogger(options = {}) {
    const prettyLog = typeof options === 'object' && 'prettyLog' in options
        ? options === null || options === void 0 ? void 0 : options.prettyLog
        : process.env.NODE_ENV === 'development';
    const logLevel = (typeof options === 'object' &&
        'logLevel' in options &&
        options.logLevel) ||
        (process.env.NODE_ENV === 'development' ? 'debug' : 'info');
    const prettyPrintOptions = prettyLog
        ? {
            transport: {
                target: 'pino-pretty',
                options: {
                    translateTime: true,
                    colorize: true,
                },
            },
        }
        : {};
    return pino({
        ...prettyPrintOptions,
        level: logLevel,
        enabled: true,
    });
}
class YogaNodeServer extends common.YogaServer {
    constructor(options) {
        var _a;
        super({
            ...options,
            logging: typeof (options === null || options === void 0 ? void 0 : options.logging) === 'object' && 'debug' in (options === null || options === void 0 ? void 0 : options.logging)
                ? options === null || options === void 0 ? void 0 : options.logging
                : getPinoLogger(options === null || options === void 0 ? void 0 : options.logging),
        });
        this.options = options;
        this.nodeServer = null;
        this.requestListener = async (req, res) => {
            const response = await this.handleIncomingMessage(req);
            await sendNodeResponse(response, res);
        };
        this.addressInfo = {
            hostname: (options === null || options === void 0 ? void 0 : options.hostname) || '0.0.0.0',
            port: (_a = options === null || options === void 0 ? void 0 : options.port) !== null && _a !== void 0 ? _a : parseInt(process.env.PORT || '4000'),
            endpoint: (options === null || options === void 0 ? void 0 : options.endpoint) || '/graphql',
            protocol: 'http',
        };
        this.logger.debug('Setting up server.');
        if (this.graphiql) {
            this.graphiql.endpoint =
                this.graphiql.endpoint || this.addressInfo.endpoint;
        }
    }
    getNodeServer() {
        return this.nodeServer;
    }
    getAddressInfo() {
        return this.addressInfo;
    }
    async handleIncomingMessage(nodeRequest) {
        this.logger.debug('Node Request received');
        const request = await getNodeRequest(nodeRequest, this.addressInfo);
        this.logger.debug('Node Request processed');
        const response = await this.handleRequest(request);
        this.logger.debug('Response returned');
        return response;
    }
    start() {
        return new Promise((resolve, reject) => {
            var _a, _b;
            try {
                if ((_a = this.options) === null || _a === void 0 ? void 0 : _a.https) {
                    this.addressInfo.protocol = 'https';
                    this.nodeServer =
                        typeof ((_b = this.options) === null || _b === void 0 ? void 0 : _b.https) === 'object'
                            ? https.createServer(this.options.https, this.requestListener)
                            : https.createServer(this.requestListener);
                }
                else {
                    this.nodeServer = http.createServer(this.requestListener);
                }
                this.nodeServer.listen(this.addressInfo.port, this.addressInfo.hostname, () => {
                    this.logger.info(`GraphQL Server running at http://${this.addressInfo.hostname}:${this.addressInfo.port}${this.addressInfo.endpoint}.`);
                    resolve();
                });
            }
            catch (e) {
                reject(e);
            }
        });
    }
    stop() {
        this.logger.info('Shutting down GraphQL server.');
        return new Promise((resolve, reject) => {
            if (!this.nodeServer) {
                reject(new common.GraphQLYogaError('Server not running.'));
                return;
            }
            this.nodeServer.close((err) => {
                if (err != null) {
                    this.logger.error('Something went wrong :( trying to shutdown the server.', err);
                    reject(err);
                }
                else {
                    this.nodeServer = null;
                    resolve();
                }
            });
        });
    }
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    async inject({ document, variables, operationName, headers, }) {
        const response = await LightMyRequest.inject(this.requestListener, {
            method: 'POST',
            url: this.addressInfo.endpoint,
            headers,
            payload: JSON.stringify({
                query: typeof document === 'string' ? document : graphql.print(document),
                variables,
                operationName,
            }),
        });
        return {
            response,
            get executionResult() {
                return JSON.parse(response.payload);
            },
        };
    }
}
/**
 * Create a simple yet powerful GraphQL server ready for production workloads.
 * Spec compliant server that supports bleeding edge GraphQL features without any vendor lock-ins.
 *
 * Comes baked in with:
 *
 * - Envelop - Plugin system for GraphQL
 * - GraphiQL - GraphQL IDE for your browser
 * - Pino - Super fast, low overhead Node.js logger
 *
 * Example:
 * ```ts
 *  import { schema } from './schema'
 *   // Provide a GraphQL schema
 *  const server = createServer({ schema })
 *  // Start the server. Defaults to http://localhost:4000/graphql
 *  server.start()
 * ```
 */
function createServer(options) {
    return new YogaNodeServer(options);
}

Object.keys(core).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return core[k];
        }
    });
});
Object.keys(subscription).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return subscription[k];
        }
    });
});
Object.defineProperty(exports, 'GraphQLYogaError', {
    enumerable: true,
    get: function () {
        return common.GraphQLYogaError;
    }
});
Object.defineProperty(exports, 'renderGraphiQL', {
    enumerable: true,
    get: function () {
        return common.renderGraphiQL;
    }
});
Object.defineProperty(exports, 'shouldRenderGraphiQL', {
    enumerable: true,
    get: function () {
        return common.shouldRenderGraphiQL;
    }
});
exports.createServer = createServer;
