import { envelop, enableIf, useSchema, useLogger, useMaskedErrors, useExtendContext } from '@envelop/core';
export * from '@envelop/core';
export { EnvelopError as GraphQLYogaError } from '@envelop/core';
import { GraphQLError, getOperationAST, isSchema } from 'graphql';
import { useValidationCache } from '@envelop/validation-cache';
import { useParserCache } from '@envelop/parser-cache';
import { makeExecutableSchema } from '@graphql-tools/schema';
import { renderGraphiQL } from 'graphql-helix';
export { renderGraphiQL } from 'graphql-helix';
import { Response, ReadableStream, fetch } from 'cross-undici-fetch';
import { dset } from 'dset';
import { isAsyncIterable } from '@graphql-tools/utils';
export * from '@graphql-yoga/subscription';

function shouldRenderGraphiQL({ headers, method }) {
    var _a;
    return method === 'GET' && !!((_a = headers === null || headers === void 0 ? void 0 : headers.get('accept')) === null || _a === void 0 ? void 0 : _a.includes('text/html'));
}

const GETRequestParser = {
    is: (request) => request.method === 'GET',
    parse: async (request) => {
        const url = new URL(request.url);
        const operationName = url.searchParams.get('operationName') || undefined;
        const query = url.searchParams.get('query') || undefined;
        const variables = url.searchParams.get('variables') || undefined;
        const extensions = url.searchParams.get('extensions') || undefined;
        return {
            operationName,
            query,
            variables: variables ? JSON.parse(variables) : undefined,
            extensions: extensions ? JSON.parse(extensions) : undefined,
        };
    },
};
const POSTRequestParser = {
    is: (request) => request.method === 'POST',
    parse: async (request) => {
        const requestBody = await request.json();
        return {
            operationName: requestBody.operationName,
            query: requestBody.query,
            variables: requestBody.variables,
            extensions: requestBody.extensions,
        };
    },
};
const POSTMultipartFormDataRequestParser = {
    is: (request) => {
        var _a;
        return request.method === 'POST' &&
            !!((_a = request.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.startsWith('multipart/form-data'));
    },
    parse: async (request) => {
        var _a, _b;
        const requestBody = await request.formData();
        const operationsStr = ((_a = requestBody.get('operations')) === null || _a === void 0 ? void 0 : _a.toString()) || '{}';
        const operations = JSON.parse(operationsStr);
        const mapStr = ((_b = requestBody.get('map')) === null || _b === void 0 ? void 0 : _b.toString()) || '{}';
        const map = JSON.parse(mapStr);
        for (const fileIndex in map) {
            const file = requestBody.get(fileIndex);
            const [path] = map[fileIndex];
            dset(operations, path, file);
        }
        return {
            operationName: operations.operationName,
            query: operations.query,
            variables: operations.variables,
            extensions: operations.extensions,
        };
    },
};
function buildGetGraphQLParameters(parsers) {
    return async function getGraphQLParameters(request) {
        for (const parser of parsers) {
            if (parser.is(request)) {
                return parser.parse(request);
            }
        }
        return {
            operationName: undefined,
            query: undefined,
            variables: undefined,
            extensions: undefined,
        };
    };
}
const getGraphQLParameters = buildGetGraphQLParameters([
    GETRequestParser,
    POSTMultipartFormDataRequestParser,
    POSTRequestParser,
]);

let encodeString;
if ('Buffer' in globalThis) {
    encodeString = (str) => Buffer.from(str, 'utf-8');
}
else {
    const textEncoder = new TextEncoder();
    encodeString = (str) => textEncoder.encode(str);
}

function getRegularResponse(executionResult) {
    const responseBody = JSON.stringify(executionResult);
    const decodedString = encodeString(responseBody);
    const headersInit = {
        'Content-Type': 'application/json',
        'Content-Length': decodedString.byteLength.toString(),
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    return new Response(decodedString, responseInit);
}
function getMultipartResponse(asyncExecutionResult) {
    const headersInit = {
        Connection: 'keep-alive',
        'Content-Type': 'multipart/mixed; boundary="-"',
        'Transfer-Encoding': 'chunked',
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new ReadableStream({
        start(controller) {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
            controller.enqueue(`---`);
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
                controller.enqueue('\r\n-----\r\n');
                controller.close();
            }
            if (value != null) {
                const chunk = JSON.stringify(value);
                const encodedChunk = encodeString(chunk);
                controller.enqueue('\r\n');
                controller.enqueue('Content-Type: application/json; charset=utf-8\r\n');
                controller.enqueue('Content-Length: ' + encodedChunk.byteLength + '\r\n');
                controller.enqueue('\r\n');
                controller.enqueue(encodedChunk);
                if (value.hasNext) {
                    controller.enqueue('\r\n---');
                }
            }
        },
        async cancel(e) {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
        },
    });
    return new Response(readableStream, responseInit);
}
function getPushResponse(asyncExecutionResult) {
    const headersInit = {
        'Content-Type': 'text/event-stream',
        Connection: 'keep-alive',
        'Cache-Control': 'no-cache',
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new ReadableStream({
        start() {
            iterator = asyncExecutionResult[Symbol.asyncIterator]();
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
                controller.enqueue('event: complete\n\n');
                controller.close();
            } else {
                if (value != null) {
                    const chunk = JSON.stringify(value);
                    controller.enqueue(`event: next\ndata: ${chunk}\n\n`);
                } else {
                    controller.enqueue('event: next\n\n');
                }
            }
        },
        async cancel(e) {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
        },
    });
    return new Response(readableStream, responseInit);
}
async function* getSingleResult(payload) {
    yield payload;
}
function getErrorResponse({ status = 500, headers = {}, errors, isEventStream, }) {
    const payload = {
        errors,
    };
    if (isEventStream) {
        return getPushResponse(getSingleResult(payload));
    }
    return new Response(JSON.stringify(payload), {
        status,
        headers,
    });
}

async function parseQuery(query, parse) {
    if (typeof query !== 'string' && query.kind === 'Document') {
        return query;
    }
    return parse(query);
}
const getExecutableOperation = (document, operationName) => {
    const operation = getOperationAST(document, operationName);
    if (!operation) {
        throw new Error('Could not determine what operation to execute.');
    }
    return operation;
};
const processRequest = async ({ contextFactory, execute, operationName, parse, query, request, schema, subscribe, validate, variables, }) => {
    let contextValue;
    let document;
    let operation;
    const isEventStream = request.headers.get('accept') === 'text/event-stream';
    try {
        if (request.method !== 'GET' && request.method !== 'POST') {
            return getErrorResponse({
                status: 405,
                headers: {
                    Allow: 'GET, POST',
                },
                errors: [
                    new GraphQLError('GraphQL only supports GET and POST requests.'),
                ],
                isEventStream,
            });
        }
        if (query == null) {
            return getErrorResponse({
                status: 400,
                errors: [new GraphQLError('Must provide query string.')],
                isEventStream,
            });
        }
        try {
            document = await parseQuery(query, parse);
        }
        catch (e) {
            return getErrorResponse({
                status: 400,
                errors: [e],
                isEventStream,
            });
        }
        const validationErrors = validate(schema, document);
        if (validationErrors.length > 0) {
            return getErrorResponse({
                status: 400,
                errors: validationErrors,
                isEventStream,
            });
        }
        operation = getExecutableOperation(document, operationName);
        if (operation.operation === 'mutation' && request.method === 'GET') {
            return getErrorResponse({
                status: 405,
                errors: [
                    new GraphQLError('Can only perform a mutation operation from a POST request.'),
                ],
                headers: {
                    Allow: 'POST',
                },
                isEventStream,
            });
        }
        let variableValues;
        try {
            if (variables) {
                variableValues =
                    typeof variables === 'string' ? JSON.parse(variables) : variables;
            }
        }
        catch (_error) {
            return getErrorResponse({
                errors: [new GraphQLError('Variables are invalid JSON.')],
                status: 400,
                isEventStream,
            });
        }
        contextValue = await contextFactory();
        const executionArgs = {
            schema,
            document,
            contextValue,
            variableValues,
            operationName,
        };
        if (operation.operation === 'subscription') {
            const result = await subscribe(executionArgs);
            // If errors are encountered while subscribing to the operation, an execution result
            // instead of an AsyncIterable.
            if (isAsyncIterable(result)) {
                return getPushResponse(result);
            }
            else {
                if (isEventStream) {
                    return getPushResponse(result);
                }
                else {
                    return getRegularResponse(result);
                }
            }
        }
        else {
            const result = await execute(executionArgs);
            // Operations that use @defer, @stream and @live will return an `AsyncIterable` instead of an
            // execution result.
            if (isAsyncIterable(result)) {
                return isEventStream
                    ? getPushResponse(result)
                    : getMultipartResponse(result);
            }
            else {
                return getRegularResponse(result);
            }
        }
    }
    catch (error) {
        const errors = [
            error instanceof GraphQLError
                ? error
                : new GraphQLError(error.message, undefined, undefined, undefined, undefined, error),
        ];
        return getErrorResponse({
            status: 500,
            errors,
            isEventStream,
        });
    }
};

const DEFAULT_CORS_OPTIONS = {
    origin: ['*'],
    methods: ['GET', 'HEAD', 'PUT', 'PATCH', 'POST', 'DELETE'],
    optionsSuccessStatus: 204,
};
function getDefaultSchema() {
    return makeExecutableSchema({
        typeDefs: /* GraphQL */ `
      """
      Greetings from GraphQL Yoga!
      """
      type Query {
        greetings: String
      }
      type Subscription {
        """
        Current Time
        """
        time: String
      }
    `,
        resolvers: {
            Query: {
                greetings: () => 'This is the `greetings` field of the root `Query` type',
            },
            Subscription: {
                time: {
                    subscribe: async function* () {
                        while (true) {
                            yield { time: new Date().toISOString() };
                            await new Promise((resolve) => setTimeout(resolve, 1000));
                        }
                    },
                },
            },
        },
    });
}
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */
class YogaServer {
    constructor(options) {
        var _a, _b, _c;
        this.corsOptionsFactory = () => DEFAULT_CORS_OPTIONS;
        this.id = Date.now().toString();
        this.handleRequest = async (request) => {
            try {
                if (request.method === 'OPTIONS') {
                    return this.handleOptions(request);
                }
                const urlObj = new URL(request.url);
                if (urlObj.pathname === '/health') {
                    return new Response(`{ "message": "alive" }`, {
                        status: 200,
                        headers: {
                            'Content-Type': 'application/json',
                            'x-yoga-id': this.id,
                        },
                    });
                }
                if (urlObj.pathname === '/readiness') {
                    urlObj.pathname = '/health';
                    const readinessResponse = await fetch(urlObj.toString());
                    if (readinessResponse.status === 200 &&
                        readinessResponse.headers.get('x-yoga-id') === this.id) {
                        return new Response(`{ "message": "ready" }`, {
                            status: 200,
                            headers: {
                                'Content-Type': 'application/json',
                            },
                        });
                    }
                    throw new Error(`Readiness check failed with status ${readinessResponse.status}`);
                }
                this.logger.debug(`Checking if GraphiQL Request`);
                if (shouldRenderGraphiQL(request) && this.graphiql) {
                    const graphiQLBody = renderGraphiQL(this.graphiql);
                    return new Response(graphiQLBody, {
                        headers: {
                            'Content-Type': 'text/html',
                        },
                        status: 200,
                    });
                }
                this.logger.debug(`Extracting GraphQL Parameters`);
                const { query, variables, operationName } = await getGraphQLParameters(request);
                const { execute, validate, subscribe, parse, contextFactory, schema } = this.getEnveloped({
                    request,
                    query,
                    variables,
                    operationName,
                });
                this.logger.debug(`Processing Request by Helix`);
                return await processRequest({
                    request,
                    query,
                    variables,
                    operationName,
                    execute,
                    validate,
                    subscribe,
                    parse,
                    contextFactory,
                    schema,
                });
            }
            catch (err) {
                this.logger.error(err.message, err);
                const response = new Response(err.message, {
                    status: 500,
                    statusText: 'Internal Server Error',
                });
                return response;
            }
        };
        const schema = (options === null || options === void 0 ? void 0 : options.schema)
            ? isSchema(options.schema)
                ? options.schema
                : makeExecutableSchema({
                    typeDefs: options.schema.typeDefs,
                    resolvers: options.schema.resolvers,
                })
            : getDefaultSchema();
        const logger = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : true;
        this.logger =
            typeof logger === 'boolean'
                ? logger === true
                    ? console
                    : {
                        debug: () => { },
                        error: () => { },
                        warn: () => { },
                        info: () => { },
                    }
                : logger;
        const maskedErrors = (_b = options === null || options === void 0 ? void 0 : options.maskedErrors) !== null && _b !== void 0 ? _b : true;
        this.getEnveloped = envelop({
            plugins: [
                // Use the schema provided by the user
                enableIf(schema != null, useSchema(schema)),
                // Performance things
                useParserCache({
                    errorCache: new Map(),
                    documentCache: new Map(),
                }),
                useValidationCache({
                    cache: new Map(),
                }),
                // Log events - useful for debugging purposes
                enableIf(!!logger, useLogger({
                    logFn: (eventName, events) => {
                        switch (eventName) {
                            case 'execute-start':
                                const { query, variables, operationName, } = events.args.contextValue;
                                this.logger.debug(eventName);
                                this.logger.debug(query, 'query');
                                this.logger.debug(operationName, 'headers');
                                this.logger.debug(variables, 'variables');
                                break;
                            case 'execute-end':
                                this.logger.debug(eventName);
                                this.logger.debug(events.result, 'response');
                                break;
                        }
                    },
                })),
                enableIf(!!maskedErrors, useMaskedErrors(typeof maskedErrors === 'object' ? maskedErrors : undefined)),
                enableIf((options === null || options === void 0 ? void 0 : options.context) != null, useExtendContext(typeof (options === null || options === void 0 ? void 0 : options.context) === 'function'
                    ? options === null || options === void 0 ? void 0 : options.context
                    : () => options === null || options === void 0 ? void 0 : options.context)),
                ...((_c = options === null || options === void 0 ? void 0 : options.plugins) !== null && _c !== void 0 ? _c : []),
            ],
        });
        if ((options === null || options === void 0 ? void 0 : options.cors) != null) {
            if (typeof options.cors === 'function') {
                const userProvidedCorsOptionsFactory = options.cors;
                this.corsOptionsFactory = (request) => {
                    const corsOptions = userProvidedCorsOptionsFactory(request);
                    return {
                        ...DEFAULT_CORS_OPTIONS,
                        ...corsOptions,
                    };
                };
            }
            else if (typeof options.cors === 'object') {
                const corsOptions = {
                    ...DEFAULT_CORS_OPTIONS,
                    ...options.cors,
                };
                this.corsOptionsFactory = () => corsOptions;
            }
        }
        this.graphiql =
            (options === null || options === void 0 ? void 0 : options.graphiql) === false || typeof (options === null || options === void 0 ? void 0 : options.graphiql) === 'object'
                ? options.graphiql
                : {};
    }
    handleOptions(request) {
        const corsOptions = this.corsOptionsFactory(request);
        const headers = {};
        if (corsOptions.origin) {
            headers['Access-Control-Allow-Origin'] = corsOptions.origin.join(', ');
        }
        if (corsOptions.methods) {
            headers['Access-Control-Allow-Methods'] = corsOptions.methods.join(', ');
        }
        if (corsOptions.allowedHeaders) {
            headers['Access-Control-Allow-Headers'] =
                corsOptions.allowedHeaders.join(', ');
        }
        if (corsOptions.exposedHeaders) {
            headers['Access-Control-Expose-Headers'] =
                corsOptions.exposedHeaders.join(', ');
        }
        if (corsOptions.credentials) {
            headers['Access-Control-Allow-Credentials'] = 'true';
        }
        if (corsOptions.maxAge) {
            headers['Access-Control-Max-Age'] = corsOptions.maxAge.toString();
        }
        return new Response(null, {
            headers,
            status: corsOptions.optionsSuccessStatus,
        });
    }
}
function createServer(options) {
    return new YogaServer(options);
}

export { YogaServer, createServer, getDefaultSchema, shouldRenderGraphiQL };
