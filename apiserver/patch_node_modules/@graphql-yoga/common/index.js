'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const utils = require('@graphql-tools/utils');
const graphql = require('graphql');
const core = require('@envelop/core');
const validationCache = require('@envelop/validation-cache');
const parserCache = require('@envelop/parser-cache');
const schema = require('@graphql-tools/schema');
const crossUndiciFetch = require('cross-undici-fetch');
const dset = require('dset');
const subscription = require('@graphql-yoga/subscription');

const ANSI_CODES = {
    black: '\x1b[30m',
    red: '\x1b[31m',
    green: '\x1b[32m',
    yellow: '\x1b[33m',
    blue: '\x1b[34m',
    magenta: '\x1b[35m',
    cyan: '\x1b[36m',
    white: '\x1b[37m',
    reset: '\x1b[0m',
    bold: '\x1b[1m',
    orange: '\x1b[48:5:166m',
};
const warnColor = (msg) => ANSI_CODES.orange + msg + ANSI_CODES.reset;
const infoColor = (msg) => ANSI_CODES.cyan + msg + ANSI_CODES.reset;
const errorColor = (msg) => ANSI_CODES.red + msg + ANSI_CODES.reset;
const debugColor = (msg) => ANSI_CODES.magenta + msg + ANSI_CODES.reset;
const titleBold = (msg) => ANSI_CODES.bold + msg + ANSI_CODES.reset;
const isDebug = () => typeof process === 'object'
    ? process.env.DEBUG
    : // @ts-expect-error
        typeof DEBUG !== 'undefined'
            ? true
            : false;
function getPrefix() {
    return titleBold(`🧘 Yoga -`);
}
function getLoggerMessage(...args) {
    return args
        .map((arg) => (typeof arg === 'string' ? arg : utils.inspect(arg)))
        .join(` `);
}
const defaultYogaLogger = {
    debug(...args) {
        if (isDebug()) {
            const message = getLoggerMessage(...args);
            const fullMessage = `🐛 ${getPrefix()} ${debugColor(message)}`;
            // Some environments don't have other console methods
            if (console.debug) {
                console.debug(fullMessage);
            }
            else {
                console.log(fullMessage);
            }
        }
    },
    info(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `💡 ${getPrefix()} ${infoColor(message)}`;
        if (console.info) {
            console.info(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
    warn(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `⚠️ ${getPrefix()} ${warnColor(message)}`;
        if (console.warn) {
            console.warn(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
    error(...args) {
        const message = getLoggerMessage(...args);
        const fullMessage = `❌ ${getPrefix()} ${errorColor(message)}`;
        if (console.error) {
            console.error(fullMessage);
        }
        else {
            console.log(fullMessage);
        }
    },
};

let encodeString;
if (globalThis.Buffer) {
    encodeString = function encodeStringWithBuffer(str) {
        return globalThis.Buffer.from(str, 'utf8');
    };
}
else {
    const textEncoder = new TextEncoder();
    encodeString = function encodeStringWithTextEncoder(str) {
        return textEncoder.encode(str);
    };
}

function getErrorResponse({ status = 500, headers = {}, errors, fetchAPI, }) {
    const payload = {
        data: null,
        errors: errors.map((error) => error instanceof graphql.GraphQLError ? error : new graphql.GraphQLError(error.message)),
    };
    const decodedString = encodeString(JSON.stringify(payload));
    return new fetchAPI.Response(decodedString, {
        status,
        headers: {
            ...headers,
            'Content-Type': 'application/json',
            'Content-Length': decodedString.byteLength.toString(),
        },
    });
}
async function processRequest({ request, params, enveloped, fetchAPI, onResultProcessHooks, }) {
    var _a;
    let document;
    if (request.method !== 'GET' && request.method !== 'POST') {
        return getErrorResponse({
            status: 405,
            headers: {
                Allow: 'GET, POST',
            },
            errors: [
                new core.EnvelopError('GraphQL only supports GET and POST requests.'),
            ],
            fetchAPI,
        });
    }
    if (params.query == null) {
        return getErrorResponse({
            status: 400,
            errors: [new core.EnvelopError('Must provide query string.')],
            fetchAPI,
        });
    }
    try {
        document = enveloped.parse(params.query);
    }
    catch (e) {
        return getErrorResponse({
            status: 400,
            errors: [e],
            fetchAPI,
        });
    }
    const validationErrors = enveloped.validate(enveloped.schema, document);
    if (validationErrors.length > 0) {
        return getErrorResponse({
            status: 400,
            errors: validationErrors,
            fetchAPI,
        });
    }
    const operation = (_a = graphql.getOperationAST(document, params.operationName)) !== null && _a !== void 0 ? _a : undefined;
    if (!operation) {
        return getErrorResponse({
            status: 400,
            errors: [
                new core.EnvelopError('Could not determine what operation to execute.'),
            ],
            fetchAPI,
        });
    }
    if (operation.operation === 'mutation' && request.method === 'GET') {
        return getErrorResponse({
            status: 405,
            headers: {
                Allow: 'POST',
            },
            errors: [
                new core.EnvelopError('Can only perform a mutation operation from a POST request.'),
            ],
            fetchAPI,
        });
    }
    let contextValue;
    try {
        contextValue = (await enveloped.contextFactory());
    }
    catch (error) {
        if (error instanceof graphql.GraphQLError) {
            return getErrorResponse({
                status: 200,
                errors: [error],
                fetchAPI,
            });
        }
        throw error;
    }
    const executionArgs = {
        schema: enveloped.schema,
        document,
        contextValue,
        variableValues: params.variables,
        operationName: params.operationName,
    };
    const executeFn = operation.operation === 'subscription'
        ? enveloped.subscribe
        : enveloped.execute;
    const result = await executeFn(executionArgs);
    let resultProcessor = (_, fetchAPI) => new fetchAPI.Response(null, {
        status: 406,
        statusText: 'Not Acceptable',
    });
    for (const onResultProcessHook of onResultProcessHooks) {
        await onResultProcessHook({
            request,
            context: contextValue,
            result,
            resultProcessor,
            setResultProcessor(newResultProcessor) {
                resultProcessor = newResultProcessor;
            },
        });
    }
    return resultProcessor(result, fetchAPI);
}

function getCORSHeadersByRequestAndOptions(request, corsOptions) {
    var _a, _b;
    const headers = {
        Server: 'GraphQL Yoga',
    };
    if (corsOptions === false) {
        return headers;
    }
    // If defined origins have '*' or undefined by any means, we should allow all origins
    if (corsOptions.origin == null ||
        corsOptions.origin.length === 0 ||
        corsOptions.origin.includes('*')) {
        const currentOrigin = request.headers.get('origin');
        // If origin is available in the headers, use it
        if (currentOrigin != null) {
            headers['Access-Control-Allow-Origin'] = currentOrigin;
            // Vary by origin because there are multiple origins
            headers['Vary'] = 'Origin';
        }
        else {
            headers['Access-Control-Allow-Origin'] = '*';
        }
    }
    else if (typeof corsOptions.origin === 'string') {
        // If there is one specific origin is specified, use it directly
        headers['Access-Control-Allow-Origin'] = corsOptions.origin;
    }
    else if (Array.isArray(corsOptions.origin)) {
        // If there is only one origin defined in the array, consider it as a single one
        if (corsOptions.origin.length === 1) {
            headers['Access-Control-Allow-Origin'] = corsOptions.origin[0];
        }
        else {
            const currentOrigin = request.headers.get('origin');
            if (currentOrigin != null && corsOptions.origin.includes(currentOrigin)) {
                // If origin is available in the headers, use it
                headers['Access-Control-Allow-Origin'] = currentOrigin;
                // Vary by origin because there are multiple origins
                headers['Vary'] = 'Origin';
            }
            else {
                // There is no origin found in the headers, so we should return null
                headers['Access-Control-Allow-Origin'] = 'null';
            }
        }
    }
    if ((_a = corsOptions.methods) === null || _a === void 0 ? void 0 : _a.length) {
        headers['Access-Control-Allow-Methods'] = corsOptions.methods.join(', ');
    }
    else {
        const requestMethod = request.headers.get('access-control-request-method');
        if (requestMethod) {
            headers['Access-Control-Allow-Methods'] = requestMethod;
        }
    }
    if ((_b = corsOptions.allowedHeaders) === null || _b === void 0 ? void 0 : _b.length) {
        headers['Access-Control-Allow-Headers'] =
            corsOptions.allowedHeaders.join(', ');
    }
    else {
        const requestHeaders = request.headers.get('access-control-request-headers');
        if (requestHeaders) {
            headers['Access-Control-Allow-Headers'] = requestHeaders;
            if (headers['Vary']) {
                headers['Vary'] += ', Access-Control-Request-Headers';
            }
            headers['Vary'] = 'Access-Control-Request-Headers';
        }
    }
    if (corsOptions.credentials != null) {
        if (corsOptions.credentials === true) {
            headers['Access-Control-Allow-Credentials'] = 'true';
        }
    }
    else if (headers['Access-Control-Allow-Origin'] !== '*') {
        headers['Access-Control-Allow-Credentials'] = 'true';
    }
    if (corsOptions.exposedHeaders) {
        headers['Access-Control-Expose-Headers'] =
            corsOptions.exposedHeaders.join(', ');
    }
    if (corsOptions.maxAge) {
        headers['Access-Control-Max-Age'] = corsOptions.maxAge.toString();
    }
    return headers;
}
async function getCORSResponseHeaders(request, serverContext, corsOptionsFactory) {
    const corsOptions = await corsOptionsFactory(request, serverContext);
    return getCORSHeadersByRequestAndOptions(request, corsOptions);
}
function useCORS(options) {
    let corsOptionsFactory = () => ({});
    if (options != null) {
        if (typeof options === 'function') {
            corsOptionsFactory = options;
        }
        else if (typeof options === 'object') {
            const corsOptions = {
                ...options,
            };
            corsOptionsFactory = () => corsOptions;
        }
        else if (options === false) {
            corsOptionsFactory = () => false;
        }
    }
    return {
        async onRequest({ request, serverContext, fetchAPI, endResponse }) {
            if (request.method.toUpperCase() === 'OPTIONS') {
                const headers = await getCORSResponseHeaders(request, serverContext, corsOptionsFactory);
                const response = new fetchAPI.Response(null, {
                    status: 204,
                    headers,
                });
                endResponse(response);
                return;
            }
        },
        async onResponse({ request, serverContext, response }) {
            const headers = await getCORSResponseHeaders(request, serverContext, corsOptionsFactory);
            for (const headerName in headers) {
                response.headers.set(headerName, headers[headerName]);
            }
        },
    };
}

function useHealthCheck(options) {
    const id = (options === null || options === void 0 ? void 0 : options.id) || Date.now().toString();
    const logger = (options === null || options === void 0 ? void 0 : options.logger) || console;
    return {
        async onRequest({ request, endResponse, fetchAPI }) {
            const requestPath = request.url.split('?')[0];
            if (requestPath.endsWith('/health')) {
                logger.debug(`Responding Health Check`);
                const response = new fetchAPI.Response(JSON.stringify({
                    message: 'alive',
                }), {
                    status: 200,
                    headers: {
                        'Content-Type': 'application/json',
                        'x-yoga-id': id,
                    },
                });
                endResponse(response);
            }
            else if (requestPath.endsWith('/readiness')) {
                logger.debug(`Responding Readiness Check`);
                const readinessResponse = await fetchAPI.fetch(request.url.replace('/readiness', '/health'));
                const { message } = await readinessResponse.json();
                if (readinessResponse.status === 200 &&
                    readinessResponse.headers.get('x-yoga-id') === id &&
                    message === 'alive') {
                    const response = new fetchAPI.Response(JSON.stringify({
                        message: 'ready',
                    }), {
                        status: 200,
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    });
                    endResponse(response);
                }
                else {
                    throw new core.EnvelopError(`Readiness check failed with status ${readinessResponse.status}`);
                }
            }
        },
    };
}

const graphiqlHTML = "<!doctype html><html lang=en><meta charset=utf-8><title>__TITLE__</title><link href=https://www.graphql-yoga.com/favicon.ico rel=icon><link href=https://unpkg.com/@graphql-yoga/graphiql@2.4.0/dist/style.css rel=stylesheet><body class=no-focus-outline id=body><noscript>You need to enable JavaScript to run this app.</noscript><div id=root></div><script type=module>import{renderYogaGraphiQL as r}from\"https://unpkg.com/@graphql-yoga/graphiql@2.4.0\";r(root,__OPTS__);</script>";

function shouldRenderGraphiQL({ headers, method }) {
    var _a;
    return method === 'GET' && !!((_a = headers === null || headers === void 0 ? void 0 : headers.get('accept')) === null || _a === void 0 ? void 0 : _a.includes('text/html'));
}
const renderGraphiQL = (opts) => graphiqlHTML
    .replace('__TITLE__', (opts === null || opts === void 0 ? void 0 : opts.title) || 'Yoga GraphiQL')
    .replace('__OPTS__', JSON.stringify(opts !== null && opts !== void 0 ? opts : {}));
function useGraphiQL(config) {
    var _a, _b;
    const logger = (_a = config === null || config === void 0 ? void 0 : config.logger) !== null && _a !== void 0 ? _a : console;
    let graphiqlOptionsFactory;
    if (typeof (config === null || config === void 0 ? void 0 : config.options) === 'function') {
        graphiqlOptionsFactory = config === null || config === void 0 ? void 0 : config.options;
    }
    else if (typeof (config === null || config === void 0 ? void 0 : config.options) === 'object') {
        graphiqlOptionsFactory = () => config === null || config === void 0 ? void 0 : config.options;
    }
    else if ((config === null || config === void 0 ? void 0 : config.options) === false) {
        graphiqlOptionsFactory = () => false;
    }
    else {
        graphiqlOptionsFactory = () => ({});
    }
    const renderer = (_b = config === null || config === void 0 ? void 0 : config.render) !== null && _b !== void 0 ? _b : renderGraphiQL;
    return {
        async onRequest({ request, serverContext, fetchAPI, endResponse }) {
            const requestPath = request.url.split('?')[0];
            if ((config === null || config === void 0 ? void 0 : config.endpoint) != null && !requestPath.endsWith(config === null || config === void 0 ? void 0 : config.endpoint)) {
                logger.debug(`Responding 404 Not Found`);
                const response = new fetchAPI.Response(`Unable to ${request.method} ${requestPath}`, {
                    status: 404,
                    statusText: `Not Found`,
                });
                endResponse(response);
            }
            else if (shouldRenderGraphiQL(request)) {
                logger.debug(`Rendering GraphiQL`);
                const graphiqlOptions = graphiqlOptionsFactory(request, serverContext);
                if (graphiqlOptions) {
                    const graphiQLBody = await renderer({
                        endpoint: config === null || config === void 0 ? void 0 : config.endpoint,
                        ...(graphiqlOptions === true ? {} : graphiqlOptions),
                    });
                    const response = new fetchAPI.Response(graphiQLBody, {
                        headers: {
                            'Content-Type': 'text/html',
                        },
                        status: 200,
                    });
                    endResponse(response);
                }
            }
        },
    };
}

const DEFAULT_MATCHER = () => true;
function useRequestParser(options) {
    const matchFn = options.match || DEFAULT_MATCHER;
    return {
        onRequestParse({ request, setRequestParser }) {
            if (matchFn(request)) {
                setRequestParser(function useRequestParserFn(request) {
                    return options.parse(request);
                });
            }
        },
    };
}

function parseURLSearchParams(requestBody) {
    const searchParams = new URLSearchParams(requestBody);
    const operationName = searchParams.get('operationName') || undefined;
    const query = searchParams.get('query') || undefined;
    const variablesStr = searchParams.get('variables') || undefined;
    const extensionsStr = searchParams.get('extensions') || undefined;
    return {
        operationName,
        query,
        variables: variablesStr ? JSON.parse(variablesStr) : undefined,
        extensions: extensionsStr ? JSON.parse(extensionsStr) : undefined,
    };
}
function isContentTypeMatch(request, expectedContentType) {
    const contentType = request.headers.get('content-type');
    return (contentType === expectedContentType ||
        !!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(`${expectedContentType};`)));
}

function isGETRequest(request) {
    return request.method === 'GET';
}
function parseGETRequest(request) {
    const [, searchParamsStr] = request.url.split('?');
    return parseURLSearchParams(searchParamsStr);
}

function isPOSTJsonRequest(request) {
    return (request.method === 'POST' &&
        (isContentTypeMatch(request, 'application/json') ||
            isContentTypeMatch(request, 'application/graphql+json')));
}
async function parsePOSTJsonRequest(request) {
    const requestBody = await request.json();
    return {
        operationName: requestBody.operationName,
        query: requestBody.query,
        variables: requestBody.variables,
        extensions: requestBody.extensions,
    };
}

function isPOSTMultipartRequest(request) {
    return (request.method === 'POST' &&
        isContentTypeMatch(request, 'multipart/form-data'));
}
async function parsePOSTMultipartRequest(request) {
    var _a, _b;
    const requestBody = await request.formData();
    const operationsStr = ((_a = requestBody.get('operations')) === null || _a === void 0 ? void 0 : _a.toString()) || '{}';
    const operations = JSON.parse(operationsStr);
    const mapStr = ((_b = requestBody.get('map')) === null || _b === void 0 ? void 0 : _b.toString()) || '{}';
    const map = JSON.parse(mapStr);
    for (const fileIndex in map) {
        const file = requestBody.get(fileIndex);
        const keys = map[fileIndex];
        for (const key of keys) {
            dset.dset(operations, key, file);
        }
    }
    return {
        operationName: operations.operationName,
        query: operations.query,
        variables: operations.variables,
        extensions: operations.extensions,
    };
}

function isPOSTGraphQLStringRequest(request) {
    return (request.method === 'POST' &&
        isContentTypeMatch(request, 'application/graphql'));
}
async function parsePOSTGraphQLStringRequest(request) {
    const requestBody = await request.text();
    return {
        query: requestBody,
    };
}

function useResultProcessor(options) {
    const isMatch = options.match || (() => true);
    return {
        onResultProcess({ request, result, setResultProcessor }) {
            if (isMatch(request, result)) {
                setResultProcessor(options.processResult);
            }
        },
    };
}

function isRegularResult(request, result) {
    return !utils.isAsyncIterable(result);
}
function processRegularResult(executionResult, fetchAPI) {
    const responseBody = JSON.stringify(executionResult);
    const decodedString = encodeString(responseBody);
    const headersInit = {
        'Content-Type': 'application/json',
        'Content-Length': decodedString.byteLength.toString(),
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    return new fetchAPI.Response(decodedString, responseInit);
}

function isPushResult(request, result) {
    var _a;
    return (core.isAsyncIterable(result) &&
        !!((_a = request.headers.get('accept')) === null || _a === void 0 ? void 0 : _a.includes('text/event-stream')));
}
function processPushResult(result, fetchAPI) {
    const headersInit = {
        'Content-Type': 'text/event-stream',
        Connection: 'keep-alive',
        'Cache-Control': 'no-cache',
        'Content-Encoding': 'none',
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new fetchAPI.ReadableStream({
        start() {
            iterator = result[Symbol.asyncIterator]();
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (done) {
                controller.enqueue(encodeString('event: complete\n\n'));
                controller.close();
            } else if (value != null) {
                const chunk = JSON.stringify(value);
                controller.enqueue(encodeString(`event: next\ndata: ${chunk}\n\n`));
            } else {
                controller.enqueue(encodeString('event: next\n\n'));
            }
        },
        async cancel(e) {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
        },
    });
    return new fetchAPI.Response(readableStream, responseInit);
}

function isMultipartResult(request, result) {
    var _a;
    return (core.isAsyncIterable(result) &&
        !!((_a = request.headers.get('accept')) === null || _a === void 0 ? void 0 : _a.includes('multipart/mixed')));
}
function processMultipartResult(executionPatchResultIterable, fetchAPI) {
    const headersInit = {
        Connection: 'keep-alive',
        'Content-Type': 'multipart/mixed; boundary="-"',
        'Transfer-Encoding': 'chunked',
    };
    const responseInit = {
        headers: headersInit,
        status: 200,
    };
    let iterator;
    const readableStream = new fetchAPI.ReadableStream({
        start(controller) {
            iterator = executionPatchResultIterable[Symbol.asyncIterator]();
            controller.enqueue(encodeString(`---`));
        },
        async pull(controller) {
            const { done, value } = await iterator.next();
            if (value != null) {
                controller.enqueue(encodeString('\r\n'));
                controller.enqueue(encodeString('Content-Type: application/json; charset=utf-8'));
                controller.enqueue(encodeString('\r\n'));
                const chunk = JSON.stringify(value);
                const encodedChunk = encodeString(chunk);
                controller.enqueue(encodeString('Content-Length: ' + encodedChunk.byteLength));
                controller.enqueue(encodeString('\r\n'));
                controller.enqueue(encodeString('\r\n'));
                controller.enqueue(encodedChunk);
                controller.enqueue(encodeString('\r\n'));
                controller.enqueue(encodeString('---'));
            }
            if (done) {
                controller.enqueue(encodeString('\r\n-----\r\n'));
                controller.close();
            }
        },
        async cancel(e) {
            var _a;
            await ((_a = iterator.return) === null || _a === void 0 ? void 0 : _a.call(iterator, e));
        },
    });
    return new fetchAPI.Response(readableStream, responseInit);
}

function isPOSTFormUrlEncodedRequest(request) {
    return (request.method === 'POST' &&
        isContentTypeMatch(request, 'application/x-www-form-urlencoded'));
}
async function parsePOSTFormUrlEncodedRequest(request) {
    const requestBody = await request.text();
    return parseURLSearchParams(requestBody);
}

function getDefaultSchema() {
    return schema.makeExecutableSchema({
        typeDefs: /* GraphQL */ `
      """
      Greetings from GraphQL Yoga!
      """
      type Query {
        greetings: String
      }
      type Subscription {
        """
        Current Time
        """
        time: String
      }
    `,
        resolvers: {
            Query: {
                greetings: () => 'This is the `greetings` field of the root `Query` type',
            },
            Subscription: {
                time: {
                    async *subscribe() {
                        while (true) {
                            yield { time: new Date().toISOString() };
                            await new Promise((resolve) => setTimeout(resolve, 1000));
                        }
                    },
                },
            },
        },
    });
}
/**
 * Base class that can be extended to create a GraphQL server with any HTTP server framework.
 * @internal
 */
class YogaServer {
    constructor(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        this.handleRequest = async (request, ...args) => {
            const response = await this.getResponse(request, ...args);
            for (const onResponseHook of this.onResponseHooks) {
                await onResponseHook({
                    request,
                    response,
                    serverContext: args[0],
                });
            }
            return response;
        };
        this.fetch = (input, init) => {
            let request;
            if (typeof input === 'string') {
                request = new this.fetchAPI.Request(input, init);
            }
            else {
                request = input;
            }
            return this.handleRequest(request, init);
        };
        // FetchEvent is not available in all envs
        this.fetchEventListener = (event) => event.respondWith(this.handleRequest(event.request, event));
        this.id = (_a = options === null || options === void 0 ? void 0 : options.id) !== null && _a !== void 0 ? _a : 'yoga';
        this.fetchAPI = {
            Request: (_c = (_b = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _b === void 0 ? void 0 : _b.Request) !== null && _c !== void 0 ? _c : crossUndiciFetch.Request,
            Response: (_e = (_d = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _d === void 0 ? void 0 : _d.Response) !== null && _e !== void 0 ? _e : crossUndiciFetch.Response,
            fetch: (_g = (_f = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _f === void 0 ? void 0 : _f.fetch) !== null && _g !== void 0 ? _g : crossUndiciFetch.fetch,
            ReadableStream: (_j = (_h = options === null || options === void 0 ? void 0 : options.fetchAPI) === null || _h === void 0 ? void 0 : _h.ReadableStream) !== null && _j !== void 0 ? _j : crossUndiciFetch.ReadableStream,
        };
        const schema$1 = (options === null || options === void 0 ? void 0 : options.schema)
            ? graphql.isSchema(options.schema)
                ? options.schema
                : schema.makeExecutableSchema({
                    typeDefs: options.schema.typeDefs,
                    resolvers: options.schema.resolvers,
                })
            : getDefaultSchema();
        const logger = (options === null || options === void 0 ? void 0 : options.logging) != null ? options.logging : true;
        this.logger =
            typeof logger === 'boolean'
                ? logger === true
                    ? defaultYogaLogger
                    : {
                        debug: () => { },
                        error: () => { },
                        warn: () => { },
                        info: () => { },
                    }
                : logger;
        const maskedErrors = (_k = options === null || options === void 0 ? void 0 : options.maskedErrors) !== null && _k !== void 0 ? _k : true;
        const server = this;
        this.endpoint = options === null || options === void 0 ? void 0 : options.endpoint;
        this.plugins = [
            // Use the schema provided by the user
            core.enableIf(schema$1 != null, core.useSchema(schema$1)),
            // Performance things
            core.enableIf((options === null || options === void 0 ? void 0 : options.parserCache) !== false, () => parserCache.useParserCache(typeof (options === null || options === void 0 ? void 0 : options.parserCache) === 'object'
                ? options === null || options === void 0 ? void 0 : options.parserCache
                : undefined)),
            core.enableIf((options === null || options === void 0 ? void 0 : options.validationCache) !== false, () => validationCache.useValidationCache({
                cache: typeof (options === null || options === void 0 ? void 0 : options.validationCache) === 'object'
                    ? options === null || options === void 0 ? void 0 : options.validationCache
                    : undefined,
            })),
            // Log events - useful for debugging purposes
            core.enableIf(logger !== false, core.useLogger({
                skipIntrospection: true,
                logFn: (eventName, events) => {
                    switch (eventName) {
                        case 'execute-start':
                        case 'subscribe-start':
                            this.logger.debug(titleBold('Execution start'));
                            const { query, operationName, variables, extensions, } = events.args.contextValue;
                            if (query) {
                                this.logger.debug('\n' + titleBold('Received GraphQL operation:') + '\n', query);
                            }
                            if (operationName) {
                                this.logger.debug('\t operationName:', operationName);
                            }
                            if (variables) {
                                this.logger.debug('\t variables:', variables);
                            }
                            if (extensions) {
                                this.logger.debug('\t extensions:', extensions);
                            }
                            break;
                        case 'execute-end':
                        case 'subscribe-end':
                            this.logger.debug(titleBold('Execution end'));
                            this.logger.debug('\t result:', events.result);
                            break;
                    }
                },
            })),
            core.enableIf((options === null || options === void 0 ? void 0 : options.context) != null, core.useExtendContext(async (initialContext) => {
                if (options === null || options === void 0 ? void 0 : options.context) {
                    if (typeof options.context === 'function') {
                        return options.context(initialContext);
                    }
                    return options.context;
                }
            })),
            // Middlewares before processing the incoming HTTP request
            useHealthCheck({
                id: this.id,
                logger: this.logger,
            }),
            core.enableIf((options === null || options === void 0 ? void 0 : options.graphiql) !== false, () => useGraphiQL({
                get endpoint() {
                    return server.endpoint;
                },
                options: options === null || options === void 0 ? void 0 : options.graphiql,
                render: options === null || options === void 0 ? void 0 : options.renderGraphiQL,
                logger: this.logger,
            })),
            core.enableIf((options === null || options === void 0 ? void 0 : options.cors) !== false, () => useCORS(options === null || options === void 0 ? void 0 : options.cors)),
            // Middlewares before the GraphQL execution
            useRequestParser({
                match: isGETRequest,
                parse: parseGETRequest,
            }),
            useRequestParser({
                match: isPOSTJsonRequest,
                parse: parsePOSTJsonRequest,
            }),
            core.enableIf((options === null || options === void 0 ? void 0 : options.multipart) !== false, () => useRequestParser({
                match: isPOSTMultipartRequest,
                parse: parsePOSTMultipartRequest,
            })),
            useRequestParser({
                match: isPOSTGraphQLStringRequest,
                parse: parsePOSTGraphQLStringRequest,
            }),
            useRequestParser({
                match: isPOSTFormUrlEncodedRequest,
                parse: parsePOSTFormUrlEncodedRequest,
            }),
            // Middlewares after the GraphQL execution
            useResultProcessor({
                match: isRegularResult,
                processResult: processRegularResult,
            }),
            useResultProcessor({
                match: isPushResult,
                processResult: processPushResult,
            }),
            useResultProcessor({
                match: isMultipartResult,
                processResult: processMultipartResult,
            }),
            ...((_l = options === null || options === void 0 ? void 0 : options.plugins) !== null && _l !== void 0 ? _l : []),
            core.enableIf(!!maskedErrors, core.useMaskedErrors(typeof maskedErrors === 'object' ? maskedErrors : undefined)),
        ];
        this.getEnveloped = core.envelop({
            plugins: this.plugins,
        });
        this.onRequestHooks = [];
        this.onRequestParseHooks = [];
        this.onResultProcessHooks = [];
        this.onResponseHooks = [];
        for (const plugin of this.plugins) {
            if (plugin) {
                if (plugin.onRequestParse) {
                    this.onRequestParseHooks.push(plugin.onRequestParse);
                }
                if (plugin.onRequest) {
                    this.onRequestHooks.push(plugin.onRequest);
                }
                if (plugin.onResultProcess) {
                    this.onResultProcessHooks.push(plugin.onResultProcess);
                }
                if (plugin.onResponse) {
                    this.onResponseHooks.push(plugin.onResponse);
                }
            }
        }
    }
    async getResponse(request, ...args) {
        var _a;
        const serverContext = args[0];
        try {
            for (const onRequestHook of this.onRequestHooks) {
                let response;
                await onRequestHook({
                    request,
                    serverContext,
                    fetchAPI: this.fetchAPI,
                    endResponse(newResponse) {
                        response = newResponse;
                    },
                });
                if (response) {
                    return response;
                }
            }
            let requestParser;
            const onRequestParseDoneList = [];
            for (const onRequestParse of this.onRequestParseHooks) {
                const onRequestParseResult = await onRequestParse({
                    serverContext,
                    request,
                    requestParser,
                    setRequestParser(parser) {
                        requestParser = parser;
                    },
                });
                if ((onRequestParseResult === null || onRequestParseResult === void 0 ? void 0 : onRequestParseResult.onRequestParseDone) != null) {
                    onRequestParseDoneList.push(onRequestParseResult.onRequestParseDone);
                }
            }
            this.logger.debug(`Parsing request to extract GraphQL parameters`);
            if (!requestParser) {
                return new this.fetchAPI.Response('Request is not valid', {
                    status: 400,
                    statusText: 'Bad Request',
                });
            }
            let params;
            try {
                params = await requestParser(request);
            }
            catch (err) {
                if (err instanceof Error) {
                    return getErrorResponse({
                        status: 400,
                        errors: [err],
                        fetchAPI: this.fetchAPI,
                    });
                }
                throw err;
            }
            for (const onRequestParseDone of onRequestParseDoneList) {
                await onRequestParseDone({
                    params,
                    setParams(newParams) {
                        params = newParams;
                    },
                });
            }
            const initialContext = {
                request,
                ...params,
                ...serverContext,
            };
            const enveloped = this.getEnveloped(initialContext);
            this.logger.debug(`Processing GraphQL Parameters`);
            const result = await processRequest({
                request,
                params,
                enveloped,
                fetchAPI: this.fetchAPI,
                onResultProcessHooks: this.onResultProcessHooks,
            });
            return result;
        }
        catch (error) {
            return getErrorResponse({
                status: 500,
                errors: [new Error((_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : 'Unexpected Error.')],
                fetchAPI: this.fetchAPI,
            });
        }
    }
    /**
     * Testing utility to mock http request for GraphQL endpoint
     *
     *
     * Example - Test a simple query
     * ```ts
     * const response = await yoga.inject({
     *  document: "query { ping }",
     * })
     * expect(response.statusCode).toBe(200)
     * expect(response.data.ping).toBe('pong')
     * ```
     **/
    async inject({ document, variables, operationName, headers, serverContext, }) {
        const request = new this.fetchAPI.Request('http://localhost/graphql', {
            method: 'POST',
            headers,
            body: JSON.stringify({
                query: document &&
                    (typeof document === 'string' ? document : graphql.print(document)),
                variables,
                operationName,
            }),
        });
        const response = await this.handleRequest(request, serverContext);
        let executionResult = null;
        if (response.headers.get('content-type') === 'application/json') {
            executionResult = await response.json();
        }
        return {
            response,
            executionResult,
        };
    }
    start() {
        self.addEventListener('fetch', this.fetchEventListener);
    }
    stop() {
        self.removeEventListener('fetch', this.fetchEventListener);
    }
}
function createServer(options) {
    const server = new YogaServer(options);
    // TODO: Will be removed once we get rid of classes
    const fnHandler = (input) => {
        if (input.request) {
            return server.handleRequest(input.request, input);
        }
        return server.handleRequest(input, undefined);
    };
    return new Proxy(fnHandler, {
        get: (_, prop) => {
            if (server[prop]) {
                if (server[prop].bind) {
                    return server[prop].bind(server);
                }
                return server[prop];
            }
            if (fnHandler[prop]) {
                if (fnHandler[prop].bind) {
                    return fnHandler[prop].bind(fnHandler);
                }
                return fnHandler[prop];
            }
        },
        apply(_, __, [input]) {
            return fnHandler(input);
        },
    });
}

Object.keys(core).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return core[k];
        }
    });
});
Object.keys(subscription).forEach(function (k) {
    if (k !== 'default') Object.defineProperty(exports, k, {
        enumerable: true,
        get: function () {
            return subscription[k];
        }
    });
});
Object.defineProperty(exports, 'GraphQLYogaError', {
    enumerable: true,
    get: function () {
        return core.EnvelopError;
    }
});
exports.YogaServer = YogaServer;
exports.createServer = createServer;
exports.debugColor = debugColor;
exports.defaultYogaLogger = defaultYogaLogger;
exports.errorColor = errorColor;
exports.getDefaultSchema = getDefaultSchema;
exports.infoColor = infoColor;
exports.renderGraphiQL = renderGraphiQL;
exports.shouldRenderGraphiQL = shouldRenderGraphiQL;
exports.titleBold = titleBold;
exports.warnColor = warnColor;
