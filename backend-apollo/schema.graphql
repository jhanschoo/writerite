# TODO: refactor once graphql supports `extend`
# https://github.com/graphql/graphql-js/issues/922\

# Note: null in inputs are allowed only in update-style methods,
#   meaning that the field should be nulled.
#scalar Upload
scalar DateTime
scalar JSON
scalar JSONObject

directive @subscriptionsTriggered(
  signatures: [String!]!
) on FIELD_DEFINITION

enum ChatMsgContentType {
  TEXT
  CONFIG
}

enum UpdateType {
  CREATED
  EDITED
  DELETED
}

enum DecksQueryScope {
  OWNED
  PARTICIPATED
  VISIBLE
}

type Query {
  # User
  user(id: ID!): User
  # Deck
  deck(id: ID!): Deck
  # implicit limit of 60
  decks(cursor: ID take: Int titleFilter: String scope: DecksQueryScope): [Deck]
  # Card
  card(id: ID!): Card
  cardsOfDeck(deckId: ID!): [Card]
  # Room
  room(id: ID!): Room
  occupiedRooms: [Room]
  # ChatMsg
  chatMsg(id: ID!): ChatMsg
  chatMsgsOfRoom(roomId: ID!): [ChatMsg]
}

type Mutation {
  # Authorization
  signin(
    email: String!
    name: String # non-null
    token: String!
    authorizer: String!
    identifier: String!
    persist: Boolean # non-null
  ): AuthResponse

  # User
  userEdit(name: String): User

  # Deck
  deckCreate(
    name: String # non-null
    description: JSONObject # non-null
    promptLang: String # non-null
    answerLang: String # non-null
    published: Boolean # non-null
  ): Deck @subscriptionsTriggered(
    signatures: ["ownDecksUpdates"]
  )

  deckCreateFromRows(
    name: String # non-null
    description: JSONObject # non-null
    promptLang: String # non-null
    answerLang: String # non-null
    published: Boolean # non-null
    rows: [[String!]!]!
  ): Deck @subscriptionsTriggered(
    signatures: ["ownDecksUpdates"]
  )

  deckEdit(
    id: ID!
    name: String # non-null
    description: JSONObject # non-null
    promptLang: String # non-null
    answerLang: String # non-null
    published: Boolean # non-null
  ): Deck @subscriptionsTriggered(
    signatures: ["ownDecksUpdates"]
  )

  deckAddSubdeck(
    id: ID! subdeckId: ID!
  ): Deck @subscriptionsTriggered(
    signatures: ["ownDecksUpdates"]
  )

  deckRemoveSubdeck(
    id: ID! subdeckId: ID!
  ): Deck @subscriptionsTriggered(
    signatures: ["ownDecksUpdates"]
  )

  deckDelete(
    id: ID!
  ): Deck @subscriptionsTriggered(
    signatures: ["ownDecksUpdates"]
  )

  # Card
  cardCreate(
    deckId: ID!
    prompt: String!
    fullAnswer: String!
    answers: [String] # non-null
    sortKey: String # non-null
    template: Boolean # non-null
  ): Card @subscriptionsTriggered(
    signatures: ["cardsOfDeckUpdates(deckId)"]
  )

  cardsCreate(
    deckId: ID!
    prompt: String!
    fullAnswer: String!
    answers: [String!] # non-null
    sortKey: String # non-null
    template: Boolean # non-null
    multiplicity: Int!
  ): [Card] @subscriptionsTriggered(
    signatures: ["cardsOfDeckUpdates(deckId)"]
  )

  cardEdit(
    id: ID!
    prompt: String # non-null
    fullAnswer: String # non-null
    answers: [String!] # non-null
    sortKey: String # non-null
    template: Boolean # non-null
  ): Card @subscriptionsTriggered(
    signatures: ["cardsOfDeckUpdates(deckId)"]
  )

  cardDelete(
    id: ID!
  ): Card @subscriptionsTriggered(
    signatures: ["cardsOfDeckUpdates(deckId)"]
  )

  # Room
  roomCreate(
    config: RoomConfigInput!
  ): Room @subscriptionsTriggered(
    signatures: ["roomUpdates(<id>)"]
  )
  roomUpdateConfig(
    id: ID!
    config: RoomConfigInput!
  ): Room @subscriptionsTriggered(
    signatures: ["roomUpdates(id)"]
  )
  roomAddOccupant(
    id: ID! occupantId: ID!
  ): Room @subscriptionsTriggered(
    signatures: ["roomUpdates(id)"]
  )
  roomArchive(
    id: ID!
  ): Room @subscriptionsTriggered(
    signatures: ["roomUpdates(id)"]
  )

  # ChatMsg
  # merge apis for different types if following RFC passes
  # https://github.com/graphql/graphql-spec/blob/master/rfcs/InputUnion.md
  chatMsgCreate(
    roomId: ID!
    type: ChatMsgContentType!
    content: String!
  ): ChatMsg @subscriptionsTriggered(
    signatures: ["chatMsgsOfRoomUpdates(roomId)"]
  )
}

type Subscription {
  # Deck
  ownDecksUpdates: DeckUpdate
  # Card
  cardsOfDeckUpdates(deckId: ID!): CardUpdate
  # Room
  roomUpdates(id: ID!): RoomUpdate
  # ChatMsg
  chatMsgsOfRoomUpdates(roomId: ID!): ChatMsgUpdate
}

type DeckUpdate {
  type: UpdateType!
  data: Deck
}
type CardUpdate {
  type: UpdateType!
  data: Card
}

type ChatMsgUpdate {
  type: UpdateType!
  data: ChatMsg
}

type RoomUpdate {
  type: UpdateType!
  data: ChatMsg
}

# User

type User {
  id: ID!
  email: String!
  roles: [String!]!
  name: String

  # R fields
  decks: [Deck]
  ownedRooms: [Room]
  occupiedRooms: [Room]
}

# Deck

type Deck {
  id: ID!
  ownerId: ID!
  name: String!
  description: JSON!
  promptLang: String!
  answerLang: String!
  published: Boolean!
  usedAt: DateTime!
  editedAt: DateTime!

  # R fields
  owner: User
  parents: [Deck]
  children: [Deck]
  cards: [Card]
}

# Card

type Card {
  id: ID!
  deckId: ID!
  prompt: String!
  fullAnswer: String!
  answers: [String!]!
  sortKey: String!
  editedAt: DateTime!
  template: Boolean!

  deck: Deck
}

# Room

input RoomConfigInput {
  deckId: ID
  deckName: String
  roundLength: Int
  clientDone: Boolean
}

type RoomConfig {
  deckId: ID
  deckName: String
  roundLength: Int
  clientDone: Boolean
}

type Room {
  id: ID!
  ownerId: ID!
  archived: Boolean!
  config: RoomConfig!

  # inactive is computed
  inactive: Boolean!
  owner: User
  occupants: [User]
  chatMsgs: [ChatMsg]
}

# ChatMsg

type ChatMsg {
  id: ID!
  roomId: ID!
  senderId: ID
  type: ChatMsgContentType!
  content: String!

  # R Fields
  sender: User # Can be null w/o error
  room: Room
}

# WrAuthorization

type AuthResponse {
  token: String!
}
