# TODO: refactor once graphql supports `extend`
# https://github.com/graphql/graphql-js/issues/922\
#scalar Upload

directive @subscriptionsTriggered(
  signatures: [String!]!
) on FIELD_DEFINITION

enum WrChatMsgContentType {
  TEXT
  CONFIG
}

type Query {
  _empty: String
  # WrUser
  wrUser(id: ID!): WrUser
  # WrDeck
  wrDeck(id: ID!): WrDeck
  wrOwnDecks: [WrDeck]
  # WrCard
  wrCard(id: ID!): WrCard
  wrCardsOfDeck(deckId: ID!): [WrCard]
  # WrRoom
  wrRoom(id: ID!): WrRoom
  wrInRooms: [WrRoom]
  # WrChatMsg
  wrChatMsg(id: ID!): WrChatMsg
  wrChatMsgsOfRoom(roomId: ID!): [WrChatMsg]
}

type Mutation {
  _empty: String

  # Authorization
  signin(opts: WrSigninOpts): WrAuthResponse

  # User
  wrUserEdit(name: String!): WrUser

  # Deck
  wrDeckCreate(
    opts: WrDeckCreateOpts!
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner>", "rwDeckTopic(<deck's id>)"]
  )
  wrDeckCreateFromRows(
    opts: WrDeckCreateOpts! rows: [[String!]!]!
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner's id>", "rwDeckTopic(<deck's id>)"]
  )
  wrDeckEdit(
    opts: WrDeckEditOpts!
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner's id>", "rwDeckTopic(<deck's id>)"]
  )
  wrDeckAddSubdeck(
    id: ID! subdeckId: ID!
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<parent deck's owner>", "rwDeckTopic(<parent deck's id>)"]
  )
  wrDeckRemoveSubdeck(
    id: ID! subdeckId: ID!
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<parent deck's owner>", "rwDeckTopic(<parent deck's id>)"]
  )
  wrDeckDelete(
    id: ID!
  ): ID @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner>", "rwDeckTopic(<deck's id>)"]
  )

  # Card
  wrCardCreate(
    opts: WrCardCreateOpts!
  ): WrCard @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<card's deck's id>)"]
  )
  wrCardsCreate(
    opts: WrCardCreateOpts!
    multiplicity: Int!
  ): [WrCard] @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<cards' deck's id>)"]
  )
  wrCardEdit(
    opts: WrCardEditOpts!
  ): WrCard @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<card's deck's id>)"]
  )
  wrCardDelete(
    id: ID!
  ): ID @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<card's deck's id>)"]
  )

  # Room
  wrRoomCreate(
    config: WrRoomConfigInput!
  ): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )
  wrRoomUpdateConfig(
    id: ID!
    config: WrRoomConfigInput!
  ): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )
  wrRoomAddOccupant(
    id: ID! occupantId: ID!
  ): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )
  wrRoomArchive(
    id: ID!
  ): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )

  # ChatMsg
  wrChatMsgCreate(
    opts: WrChatMsgCreateOpts
  ): WrChatMsg @subscriptionsTriggered(
    signatures: ["rwChatMsgUpdatesOfRoom(<room's id>)"]
  )
}

type Subscription {
  _empty: String
  # Deck
  rwOwnDecksUpdates: WrDeckUpdate!
  rwDeckUpdates(id: ID!): WrDeckUpdate!
  # Card
  rwCardsUpdatesOfDeck(deckId: ID!): WrCardUpdate!
  # Room
  rwRoomUpdates(id: ID!): WrRoomUpdate!
  # ChatMsg
  rwChatMsgsUpdatesOfRoom(roomId: ID!): WrChatMsgUpdate!
}

type WrDeckCreated { created: WrDeck }
type WrDeckUpdated { updated: WrDeck }
type WrDeckDeleted { deletedId: ID }
union WrDeckUpdate = WrDeckCreated | WrDeckUpdated | WrDeckDeleted

type WrCardCreated { created: WrCard }
type WrCardUpdated { updated: WrCard }
type WrCardDeleted { deletedId: ID }
union WrCardUpdate = WrCardCreated | WrCardUpdated | WrCardDeleted

type WrChatMsgCreated { created: WrChatMsg }
type WrChatMsgUpdated { updated: WrChatMsg }
type WrChatMsgDeleted { deletedId: ID }
union WrChatMsgUpdate = WrChatMsgCreated | WrChatMsgUpdated | WrChatMsgDeleted

type WrRoomCreated { created: WrRoom }
type WrRoomUpdated { updated: WrRoom }
type WrRoomDeleted { deletedId: ID }
union WrRoomUpdate = WrRoomCreated | WrRoomUpdated | WrRoomDeleted

# WrUser

type WrUser {
  id: ID!
  email: String!
  roles: [String!]!
  name: String

  # R fields
  decks: [WrDeck]!
  ownedRooms: [WrRoom]!
  occupiedRooms: [WrRoom]!
}

# WrDeck

input WrDeckCreateOpts {
  name: String
  description: String
  nameLang: String
  promptLang: String
  answerLang: String
}

input WrDeckEditOpts {
  id: ID!
  name: String
  description: String
  nameLang: String
  promptLang: String
  answerLang: String
}

type WrDeck {
  id: ID!
  ownerId: ID!
  name: String!
  description: String!
  promptLang: String!
  answerLang: String!
  published: Boolean!

  # R fields
  owner: WrUser
  parents: [WrDeck]!
  children: [WrDeck]!
  cards: [WrCard]!
}

# WrCard

input WrCardCreateOpts {
  deckId: ID!
  prompt: String!
  fullAnswer: String!
  answers: [String!]
  sortKey: String
  template: Boolean
}

input WrCardEditOpts {
  id: ID!
  prompt: String
  fullAnswer: String
  answers: [String!]
  sortKey: String
  template: Boolean
}

type WrCard {
  id: ID!
  deckId: ID!
  prompt: String!
  fullAnswer: String!
  answers: [String!]!
  sortKey: String!
  editedAt: String!
  template: Boolean!

  deck: WrDeck
}

# WrRoom

input WrRoomConfigInput {
  deckId: ID
  deckName: String
  deckNameLang: String
  roundLength: Int
  clientDone: Boolean
}

type WrRoomConfig {
  deckId: ID
  deckName: String
  deckNameLang: String
  roundLength: Int
  clientDone: Boolean
}

type WrRoom {
  id: ID!
  ownerId: ID!
  archived: Boolean!
  inactive: Boolean!
  config: WrRoomConfig!

  owner: WrUser
  occupants: [WrUser]!
  chatMsgs: [WrChatMsg]!
}

# WrChatMsg

input WrChatMsgCreateOpts {
  roomId: ID!
  content: String!
  contentType: WrChatMsgContentType!
}

type WrChatMsg {
  id: ID!
  roomId: ID!
  senderId: ID
  content: String!
  contentType: WrChatMsgContentType!

  # R Fields
  sender: WrUser # Can be null w/o error
  room: WrRoom
}

# WrAuthorization

input WrSigninOpts {
  email: String!
  name: String
  token: String!
  authorizer: String!
  identifier: String!
  persist: Boolean
}

type WrAuthResponse {
  user: WrUser!
  token: String!
}
