# TODO: refactor once graphql supports `extend`
# https://github.com/graphql/graphql-js/issues/922\
#scalar Upload

directive @subscriptionsTriggered(
  signatures: [String!]!
) on FIELD_DEFINITION

enum WrRoomMessageContentType {
  TEXT
  CONFIG
}

type Query {
  _empty: String
  # WrUser
  wrUser(id: ID!): WrUser
  wrUsers: [WrUser!]
  # WrDeck
  wrDeck(id: ID!): WrDeck
  wrOwnDecks: [WrDeck!]
  # WrCard
  wrCard(id: ID!): WrCard
  wrCardsOfDeck(deckId: ID!): [WrCard!]
  # WrRoom
  wrRoom(id: ID!): WrRoom
  wrInRooms: [WrRoom!]
  # WrRoomMessage
  wrRoomMessage(id: ID!): WrRoomMessage
  wrRoomMessagesOfRoom(roomId: ID!): [WrRoomMessage!]
}

type Mutation {
  _empty: String

  # Authorization
  signin(
    email: String!
    name: String
    token: String!
    authorizer: String!
    identifier: String!
    persist: Boolean
  ): WrAuthResponse

  # User
  rwUserEdit(name: String!): WrUser

  # Deck
  rwDeckCreate(
    name: String
    description: String
    nameLang: String
    promptLang: String
    answerLang: String
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner>", "rwDeckTopic(<deck's id>)"]
  )
  rwDeckCreateFromRows(
    name: String
    description: String
    nameLang: String
    promptLang: String
    answerLang: String
    rows: [[String!]!]!
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner's id>", "rwDeckTopic(<deck's id>)"]
  )
  rwDeckEdit(
    id: ID!
    name: String
    description: String
    nameLang: String
    promptLang: String
    answerLang: String
  ): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner's id>", "rwDeckTopic(<deck's id>)"]
  )
  rwDeckAddSubdeck(id: ID!, subdeckId: ID!): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<parent deck's owner>", "rwDeckTopic(<parent deck's id>)"]
  )
  rwDeckRemoveSubdeck(id: ID!, subdeckId: ID!): WrDeck @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<parent deck's owner>", "rwDeckTopic(<parent deck's id>)"]
  )
  rwDeckDelete(id: ID!): ID @subscriptionsTriggered(
    signatures: ["rwOwnDecksUpdates<deck's owner>", "rwDeckTopic(<deck's id>)"]
  )
  # Card
  rwCardCreate(
    deckId: ID!
    prompt: String!
    fullAnswer: String!
    answers: [String!]
    sortKey: String
    template: Boolean
  ): WrCard @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<card's deck's id>)"]
  )
  rwCardsCreate(
    deckId: ID!
    multiplicity: Int!
    prompt: String!
    fullAnswer: String!
    answers: [String!]
    sortKey: String
    template: Boolean
  ): [WrCard!] @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<cards' deck's id>)"]
  )
  rwCardEdit(
    id: ID!
    prompt: String
    fullAnswer: String
    answers: [String!]
    sortKey: String
    template: Boolean
  ): WrCard @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<card's deck's id>)"]
  )
  rwCardDelete(id: ID!): ID @subscriptionsTriggered(
    signatures: ["rwCardsUpdatesOfDeck(<card's deck's id>)"]
  )
  # Room
  rwRoomCreate(config: IRoomConfigInput!): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )
  rwRoomUpdateConfig(id: ID! config: IRoomConfigInput!): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )
  rwRoomAddOccupant(id: ID! occupantId: ID!): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )
  rwRoomDeactivate(id: ID!): WrRoom @subscriptionsTriggered(
    signatures: ["rwRoomUpdates(<room's id>)"]
  )

  # RoomMessage
  rwRoomMessageCreate(
    roomId: ID!
    content: String!
    contentType: WrRoomMessageContentType!
  ): WrRoomMessage @subscriptionsTriggered(
    signatures: ["rwRoomMessagesUpdatesOfRoom(<room's id>)"]
  )
}

type Subscription {
  _empty: String
  # Deck
  rwOwnDecksUpdates: WrDeckUpdate!
  rwDeckUpdates(id: ID!): WrDeckUpdate!
  # Card
  rwCardsUpdatesOfDeck(deckId: ID!): WrCardUpdate!
  # Room
  rwRoomUpdates(id: ID!): WrRoomUpdate!
  # RoomMessage
  rwRoomMessagesUpdatesOfRoom(roomId: ID!): WrRoomMessageUpdate!
}

type WrDeckCreated { created: WrDeck }
type WrDeckUpdated { updated: WrDeck }
type WrDeckDeleted { deletedId: ID }
union WrDeckUpdate = WrDeckCreated | WrDeckUpdated | WrDeckDeleted

type WrCardCreated { created: WrCard }
type WrCardUpdated { updated: WrCard }
type WrCardDeleted { deletedId: ID }
union WrCardUpdate = WrCardCreated | WrCardUpdated | WrCardDeleted

type WrRoomMessageCreated { created: WrRoomMessage }
type WrRoomMessageUpdated { updated: WrRoomMessage }
type WrRoomMessageDeleted { deletedId: ID }
union WrRoomMessageUpdate = WrRoomMessageCreated | WrRoomMessageUpdated | WrRoomMessageDeleted

type WrRoomCreated { created: WrRoom }
type WrRoomUpdated { updated: WrRoom }
type WrRoomDeleted { deletedId: ID }
union WrRoomUpdate = WrRoomCreated | WrRoomUpdated | WrRoomDeleted

# WrDeck

type WrDeck {
  id: ID!
  name: String!
  description: String!
  nameLang: String!
  promptLang: String!
  answerLang: String!
  owner: WrUser!
  subdecks: [WrDeck!]!
  cards: [WrCard!]!
}

# WrCard

type WrCard {
  id: ID!
  prompt: String!
  fullAnswer: String!
  answers: [String!]!
  sortKey: String!
  deck: WrDeck!
  editedAt: String!
  template: Boolean!
}

# WrRoom

type WrRoom {
  id: ID!
  inactive: Boolean!
  config: IRoomConfig!
  owner: WrUser!
  occupants: [WrUser!]!
  messages: [WrRoomMessage!]!
}

# WrRoomMessage

type WrRoomMessage {
  id: ID!
  content: String!
  contentType: WrRoomMessageContentType!
  sender: WrUser
  room: WrRoom
}

# WrAuthorization

type WrAuthResponse {
  user: WrUser!
  token: String!
}

# WrUser

type WrUser {
  id: ID!
  email: String!
  name: String
  roles: [String!]!
  decks: [WrDeck!]!
}

# IRoomConfig
input IRoomConfigInput {
  deckId: ID
  deckName: String
  deckNameLang: String
  roundLength: Int
  clientDone: Boolean
}

type IRoomConfig {
  deckId: ID
  deckName: String
  deckNameLang: String
  roundLength: Int
  clientDone: Boolean
}
